diff --git a/src/who.c b/src/who.c
index 06e1ab0f6..616e4a1b9 100644
--- a/src/who.c
+++ b/src/who.c
@@ -28,6 +28,10 @@
 #include <stdio.h>
 #include <assert.h>
 
+#if defined(WITH_SYSTEMD) || defined(WITH_ELOGIND)
+#include <systemd/sd-login.h>
+#endif
+
 #include <sys/types.h>
 #include "system.h"
 
@@ -557,6 +561,34 @@ list_entries_who (size_t n, const STRUCT_UTMP *utmp_buf)
   printf (_("\n# users=%lu\n"), entries);
 }
 
+#if defined(WITH_SYSTEMD) || defined(WITH_ELOGIND)
+/* Print the username of each session and the number of sessions */
+static void
+list_entries_who_logind (void)
+{
+  char const *separator = "";
+  char **sessions_list;
+  int n_sessions = sd_get_sessions (&sessions_list);
+  int i;
+
+  for (i = 0;  i < n_sessions; i++)
+    {
+      char *name;
+      int r;
+
+      if ((r = sd_session_get_username (sessions_list[i], &name)) < 0)
+	die (EXIT_FAILURE, -r, _("couldn't get user name"));
+
+      printf ("%s%s", separator, name);
+      free (name);
+      separator = " ";
+      free (sessions_list[i]);
+    }
+  free (sessions_list);
+  printf (_("\n# users=%i\n"), n_sessions);
+}
+#endif
+
 static void
 print_heading (void)
 {
@@ -615,23 +647,160 @@ scan_entries (size_t n, const STRUCT_UTMP *utmp_buf)
     }
 }
 
+#if defined(WITH_SYSTEMD) || defined(WITH_ELOGIND)
+/* Display sessions */
+static void
+scan_entries_logind (void)
+{
+  char *ttyname_b IF_LINT ( = NULL);
+  char **sessions_list;
+  int n_sessions = sd_get_sessions (&sessions_list);
+  int i;
+
+  if (include_heading)
+    print_heading ();
+
+  if (my_line_only)
+    {
+      ttyname_b = ttyname (STDIN_FILENO);
+      if (!ttyname_b)
+        return;
+      if (STRNCMP_LIT (ttyname_b, DEV_DIR_WITH_TRAILING_SLASH) == 0)
+        ttyname_b += DEV_DIR_LEN;	/* Discard /dev/ prefix.  */
+    }
+
+  for (i = 0;  i < n_sessions; i++)
+    {
+      char *host;
+      char *name;
+      char *tty;
+      int r;
+
+      if ((r = sd_session_get_username (sessions_list[i], &name)) < 0)
+	die (EXIT_FAILURE, -r, _("couldn't get user name"));
+      if ((r = sd_session_get_tty (sessions_list[i], &tty)) < 0)
+	tty = strdup ("");
+      if ((r = sd_session_get_remote_host (sessions_list[i], &host)) < 0)
+	host = NULL;
+
+      if (!my_line_only
+          || STREQ (ttyname_b, tty))
+	{
+	  if (need_users)
+	    {
+	      time_t boottime = TYPE_MINIMUM (time_t);
+	      struct stat stats;
+	      time_t last_change = 0;
+	      char mesg = '?';
+	      char idlestr[IDLESTR_LEN + 1];
+	      char *hoststr = NULL;
+
+#define DEV_DIR_WITH_TRAILING_SLASH "/dev/"
+#define DEV_DIR_LEN (sizeof (DEV_DIR_WITH_TRAILING_SLASH) - 1)
+
+	      char line[32 /* XXX */ + DEV_DIR_LEN + 1];
+	      char *p = line;
+
+	      /* Copy tty into LINE, prepending '/dev/'. tty is never
+		 an absolute file name. */
+	      p = stpcpy (p, DEV_DIR_WITH_TRAILING_SLASH);
+	      stzncpy (p, tty, strlen (tty) /* XXX */);
+
+	      if (last_change)
+		sprintf (idlestr, "%.*s", IDLESTR_LEN, idle_string (last_change, boottime));
+	      else
+		sprintf (idlestr, "  ?");
+
+	      if (stat (line, &stats) == 0)
+		{
+		  mesg = is_tty_writable (&stats) ? '+' : '-';
+		  last_change = stats.st_atime;
+		}
+
+	      if (host != NULL)
+		{
+		  host = canon_host (host);
+		  /* XXX host could now be NULL */
+		  hoststr = xmalloc (strlen (host) + 3);
+		  sprintf (hoststr, "(%s)", host);
+		}
+
+	      print_line (strlen (name), name, mesg,
+			  strlen (tty), tty,
+			  "time", idlestr, "", hoststr ? hoststr : "", "");
+	      if (hoststr)
+		free (hoststr);
+	    }
+	}
+
+      if (host)
+	free (host);
+      free (tty);
+      free (name);
+      free (sessions_list[i]);
+    }
+  free (sessions_list);
+
+#if 0 /* XXX */
+  while (n--)
+    {
+          if (need_users && IS_USER_PROCESS (utmp_buf))
+            print_user (utmp_buf, boottime);
+          else if (need_runlevel && UT_TYPE_RUN_LVL (utmp_buf))
+            print_runlevel (utmp_buf);
+          else if (need_boottime && UT_TYPE_BOOT_TIME (utmp_buf))
+            print_boottime (utmp_buf);
+          /* I've never seen one of these, so I don't know what it should
+             look like :^)
+             FIXME: handle OLD_TIME also, perhaps show the delta? */
+          else if (need_clockchange && UT_TYPE_NEW_TIME (utmp_buf))
+            print_clockchange (utmp_buf);
+          else if (need_initspawn && UT_TYPE_INIT_PROCESS (utmp_buf))
+            print_initspawn (utmp_buf);
+          else if (need_login && UT_TYPE_LOGIN_PROCESS (utmp_buf))
+            print_login (utmp_buf);
+          else if (need_deadprocs && UT_TYPE_DEAD_PROCESS (utmp_buf))
+            print_deadprocs (utmp_buf);
+        }
+
+      if (UT_TYPE_BOOT_TIME (utmp_buf))
+        boottime = UT_TIME_MEMBER (utmp_buf);
+
+      utmp_buf++;
+    }
+#endif
+}
+#endif
+
 /* Display a list of who is on the system, according to utmp file FILENAME.
    Use read_utmp OPTIONS to read the file.  */
 static void
 who (char const *filename, int options)
 {
-  size_t n_users;
-  STRUCT_UTMP *utmp_buf;
+#if defined(WITH_SYSTEMD) || defined(WITH_ELOGIND)
+  if (filename == NULL)
+    {
+      if (short_list)
+	list_entries_who_logind ();
+      else
+	scan_entries_logind ();
+    }
+  else
+#endif
+    {
+      size_t n_users;
+      STRUCT_UTMP *utmp_buf;
 
-  if (read_utmp (filename, &n_users, &utmp_buf, options) != 0)
-    die (EXIT_FAILURE, errno, "%s", quotef (filename));
+      if (read_utmp (filename, &n_users, &utmp_buf, options) != 0)
+	die (EXIT_FAILURE, errno, "%s", quotef (filename));
 
-  if (short_list)
-    list_entries_who (n_users, utmp_buf);
-  else
-    scan_entries (n_users, utmp_buf);
+      if (short_list)
+	list_entries_who (n_users, utmp_buf);
+      else
+	scan_entries (n_users, utmp_buf);
 
-  free (utmp_buf);
+      free (utmp_buf);
+    }
 }
 
 void
@@ -820,7 +989,11 @@ main (int argc, char **argv)
       FALLTHROUGH;
     case -1:
     case 0:			/* who */
+#if defined(WITH_SYSTEMD) || defined(WITH_ELOGIND)
+      who (NULL, 0);
+#else
       who (UTMP_FILE, READ_UTMP_CHECK_PIDS);
+#endif
       break;
 
     case 1:			/* who <utmp file> */
